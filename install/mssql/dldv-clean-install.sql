/*
Deployment script for model

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar SchemaName "rules"


GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
PRINT N'Creating [$(SchemaName)]...';


GO
CREATE SCHEMA [$(SchemaName)]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [$(SchemaName)].[Severity]...';


GO
CREATE TABLE [$(SchemaName)].[Severity] (
    [Name]        NVARCHAR (64)   NOT NULL,
    [Description] NVARCHAR (1024) NULL,
    CONSTRAINT [PK_$(SchemaName)_Severity] PRIMARY KEY CLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [$(SchemaName)].[JobRule]...';


GO
CREATE TABLE [$(SchemaName)].[JobRule] (
    [Job]      NVARCHAR (64) NOT NULL,
    [Rule]     NVARCHAR (64) NOT NULL,
    [Severity] NVARCHAR (64) NOT NULL,
    [Disabled] BIT           NOT NULL,
    CONSTRAINT [PK_$(SchemaName)_JobRule] PRIMARY KEY CLUSTERED ([Job] ASC, [Rule] ASC)
);


GO
PRINT N'Creating [$(SchemaName)].[Group]...';


GO
CREATE TABLE [$(SchemaName)].[Group] (
    [Name] NVARCHAR (64) NOT NULL,
    CONSTRAINT [PK_$(SchemaName)_Group] PRIMARY KEY CLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [$(SchemaName)].[Variable]...';


GO
CREATE TABLE [$(SchemaName)].[Variable] (
    [Name]        NVARCHAR (64)   NOT NULL,
    [Description] NVARCHAR (1024) NULL,
    CONSTRAINT [PK_$(SchemaName)_Variable] PRIMARY KEY CLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [$(SchemaName)].[Log]...';


GO
CREATE TABLE [$(SchemaName)].[Log] (
    [Time]      DATETIME2 (7)   NULL,
    [Job]       NVARCHAR (64)   NULL,
    [Rule]      NVARCHAR (64)   NULL,
    [Severity]  NVARCHAR (64)   NULL,
    [Status]    NVARCHAR (9)    NULL,
    [RowData]   NVARCHAR (4000) NULL,
    [Duration]  INT             NULL,
    [Exception] NVARCHAR (4000) NULL,
    [Log]       NVARCHAR (64)   NULL
);


GO
PRINT N'Creating [$(SchemaName)].[Job]...';


GO
CREATE TABLE [$(SchemaName)].[Job] (
    [Name]        NVARCHAR (64)   NOT NULL,
    [Description] NVARCHAR (1024) NULL,
    CONSTRAINT [PK_$(SchemaName)_Job] PRIMARY KEY CLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [$(SchemaName)].[RuleGroup]...';


GO
CREATE TABLE [$(SchemaName)].[RuleGroup] (
    [Group] NVARCHAR (64) NOT NULL,
    [Rule]  NVARCHAR (64) NOT NULL,
    CONSTRAINT [PK_$(SchemaName)_RuleGroup] PRIMARY KEY CLUSTERED ([Rule] ASC, [Group] ASC)
);


GO
PRINT N'Creating [$(SchemaName)].[Rule]...';


GO
CREATE TABLE [$(SchemaName)].[Rule] (
    [Name]        NVARCHAR (64)   NOT NULL,
    [Statement]   NVARCHAR (MAX)  NOT NULL,
    [Description] NVARCHAR (1024) NULL,
    CONSTRAINT [PK_$(SchemaName)_Rule] PRIMARY KEY CLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [$(SchemaName)].[JobVariable]...';


GO
CREATE TABLE [$(SchemaName)].[JobVariable] (
    [Job]      NVARCHAR (64) NOT NULL,
    [Variable] NVARCHAR (64) NOT NULL,
    [Value]    SQL_VARIANT   NOT NULL,
    CONSTRAINT [PK_$(SchemaName)_JobVariable] PRIMARY KEY CLUSTERED ([Job] ASC, [Variable] ASC)
);


GO
PRINT N'Creating [$(SchemaName)].[DF_$(SchemaName)_JobRule_Disabled]...';


GO
ALTER TABLE [$(SchemaName)].[JobRule]
    ADD CONSTRAINT [DF_$(SchemaName)_JobRule_Disabled] DEFAULT ((1)) FOR [Disabled];


GO
PRINT N'Creating [$(SchemaName)].[FK_$(SchemaName)_JobRule_Job]...';


GO
ALTER TABLE [$(SchemaName)].[JobRule] WITH NOCHECK
    ADD CONSTRAINT [FK_$(SchemaName)_JobRule_Job] FOREIGN KEY ([Job]) REFERENCES [$(SchemaName)].[Job] ([Name]) ON DELETE CASCADE ON UPDATE CASCADE;


GO
PRINT N'Creating [$(SchemaName)].[FK_$(SchemaName)_JobRule_Rule]...';


GO
ALTER TABLE [$(SchemaName)].[JobRule] WITH NOCHECK
    ADD CONSTRAINT [FK_$(SchemaName)_JobRule_Rule] FOREIGN KEY ([Rule]) REFERENCES [$(SchemaName)].[Rule] ([Name]) ON UPDATE CASCADE;


GO
PRINT N'Creating [$(SchemaName)].[FK_$(SchemaName)_JobRule_Severity]...';


GO
ALTER TABLE [$(SchemaName)].[JobRule] WITH NOCHECK
    ADD CONSTRAINT [FK_$(SchemaName)_JobRule_Severity] FOREIGN KEY ([Severity]) REFERENCES [$(SchemaName)].[Severity] ([Name]) ON UPDATE CASCADE;


GO
PRINT N'Creating [$(SchemaName)].[FK_$(SchemaName)_RuleGroup_Group]...';


GO
ALTER TABLE [$(SchemaName)].[RuleGroup] WITH NOCHECK
    ADD CONSTRAINT [FK_$(SchemaName)_RuleGroup_Group] FOREIGN KEY ([Group]) REFERENCES [$(SchemaName)].[Group] ([Name]) ON DELETE CASCADE ON UPDATE CASCADE;


GO
PRINT N'Creating [$(SchemaName)].[FK_$(SchemaName)_RuleGroup_Rule]...';


GO
ALTER TABLE [$(SchemaName)].[RuleGroup] WITH NOCHECK
    ADD CONSTRAINT [FK_$(SchemaName)_RuleGroup_Rule] FOREIGN KEY ([Rule]) REFERENCES [$(SchemaName)].[Rule] ([Name]) ON DELETE CASCADE ON UPDATE CASCADE;


GO
PRINT N'Creating [$(SchemaName)].[FK_$(SchemaName)_JobVariable_Job]...';


GO
ALTER TABLE [$(SchemaName)].[JobVariable] WITH NOCHECK
    ADD CONSTRAINT [FK_$(SchemaName)_JobVariable_Job] FOREIGN KEY ([Job]) REFERENCES [$(SchemaName)].[Job] ([Name]) ON DELETE CASCADE ON UPDATE CASCADE;


GO
PRINT N'Creating [$(SchemaName)].[FK_$(SchemaName)_JobVariable_Variable]...';


GO
ALTER TABLE [$(SchemaName)].[JobVariable] WITH NOCHECK
    ADD CONSTRAINT [FK_$(SchemaName)_JobVariable_Variable] FOREIGN KEY ([Variable]) REFERENCES [$(SchemaName)].[Variable] ([Name]);


GO
PRINT N'Creating [$(SchemaName)].[CK_$(SchemaName)_Variable_Name]...';


GO
ALTER TABLE [$(SchemaName)].[Variable] WITH NOCHECK
    ADD CONSTRAINT [CK_$(SchemaName)_Variable_Name] CHECK (NOT [Name] like '%[^A-Z]%' AND NOT [Name] like '%RESERVED');


GO
PRINT N'Creating [$(SchemaName)].[CK_$(SchemaName)_Rule_Statement]...';


GO
ALTER TABLE [$(SchemaName)].[Rule] WITH NOCHECK
    ADD CONSTRAINT [CK_$(SchemaName)_Rule_Statement] CHECK ([statement] like 'SELECT%' AND NOT [Statement] like '%;%');


GO
PRINT N'Creating [$(SchemaName)].[JobVariableHelp]...';


GO




CREATE VIEW [$(SchemaName)].[JobVariableHelp]
AS
SELECT
  JobVariable.Job,
  JobVariable.Variable,
  SQL_VARIANT_PROPERTY(JobVariable.[Value],'BaseType') AS BaseType,  
  SQL_VARIANT_PROPERTY(JobVariable.[Value],'Precision') AS [Precision],  
  SQL_VARIANT_PROPERTY(JobVariable.[Value],'Scale') AS Scale,
  SQL_VARIANT_PROPERTY(JobVariable.[Value],'MaxLength') AS [MaxLength],
  SQL_VARIANT_PROPERTY(JobVariable.[Value],'Collation') AS [Collation],
  JobVariable.[Value],
  Variable.[Description]
FROM
  [$(SchemaName)].JobVariable
  JOIN
  [$(SchemaName)].Job
    ON JobVariable.Job = Job.Name
  JOIN
  [$(SchemaName)].Variable
    ON JobVariable.[Variable] = [Variable].Name;
GO
PRINT N'Creating [$(SchemaName)].[RuleGroupHelp]...';


GO



CREATE VIEW [$(SchemaName)].[RuleGroupHelp]
AS
SELECT
  RuleGroup.[Group],
  RuleGroup.[Rule],
  [Rule].[Description]
FROM
  [$(SchemaName)].RuleGroup
  INNER JOIN
  [$(SchemaName)].[Rule]
    ON RuleGroup.[Rule] = [Rule].Name;
GO
PRINT N'Creating [$(SchemaName)].[JobRuleHelp]...';


GO




CREATE VIEW [$(SchemaName)].[JobRuleHelp]
AS
SELECT
  JobRule.Job,
  JobRule.[Rule],
  JobRule.Severity,
  JobRule.[Disabled],
  [Rule].[Description],
  [Rule].[Statement]
FROM
  [$(SchemaName)].JobRule
  INNER JOIN
  [$(SchemaName)].Job
    ON JobRule.Job = Job.Name
  INNER JOIN
  [$(SchemaName)].[Rule]
    ON JobRule.[Rule] = [Rule].Name;
GO
PRINT N'Creating [$(SchemaName)].[ConfigurePrepareDurationUnit]...';


GO





CREATE FUNCTION [$(SchemaName)].[ConfigurePrepareDurationUnit] ()
RETURNS NVARCHAR(64)
AS
BEGIN
  
  RETURN 
    'MILLISECOND'
    --'SECOND'
    ;

END
GO
PRINT N'Creating [$(SchemaName)].[ConfigurePrepareIndent]...';


GO



CREATE FUNCTION [$(SchemaName)].[ConfigurePrepareIndent] ()
RETURNS NVARCHAR(8)
AS
BEGIN
  
  RETURN 
    --'	' /* Tab */
    '  ' /* 2-Spaces */
    ;

END
GO
PRINT N'Creating [$(SchemaName)].[ConfigurePrepareNewline]...';


GO


CREATE FUNCTION [$(SchemaName)].[ConfigurePrepareNewline] ()
RETURNS NVARCHAR(2)
AS
BEGIN
  
  RETURN 
    CHAR(13) + CHAR(10);

END
GO
PRINT N'Creating [$(SchemaName)].[ConfigurePrepareRowDataFormat]...';


GO



CREATE FUNCTION [$(SchemaName)].[ConfigurePrepareRowDataFormat] ()
RETURNS NVARCHAR(64)
AS
BEGIN
  
  RETURN 
    'JSON AUTO'
    --'XML RAW'
    ;

END
GO
PRINT N'Creating [$(SchemaName)].[AssignGroup]...';


GO




/*

  AssignGroup

  Allows rules to be assigned to a job as a group. Follows the merge logic of 
  procedure AssignRule.

  Job, severity, and group must already be defined in tables Job, Severity,
  and Group, respectively.

  Parameters:

    @Job - The unique name of the job to which to assign the rules the group 
    contains.

    @Group - The unique name of the group which contains the rules to assign.

    @Severity - What severity rule failures will be treated.
    
    @Disabled - Whether the rules will be diabled on assignment. Default 
      false (0).

  Return value: 

    0 if successful, non-zero otherwise.

*/
CREATE PROCEDURE [$(SchemaName)].[AssignGroup] 
  @Job       NVARCHAR(64),
  @Group     NVARCHAR(64),
  @Severity  NVARCHAR(64),
  @Disabled  BIT = 0
AS
BEGIN
  
  SET NOCOUNT ON;

  RAISERROR('Not implemented',16,1);
    
  RETURN 1;
  
END
GO
PRINT N'Creating [$(SchemaName)].[AssignVariable]...';


GO





/*

  AssignVariable

  Assigns a variable to a job. If the variable is already assigned to the job,
  updates the value. 

  Job and vaiable must already be defined in tables Job and Variable, respectively.

  Value cannot be null.

  Parameters:

    @Job - The unique name of the job to which to assign the variable.

    @Variable - The unique name of the variable to assign.

    @Value - The value to assign the variable.

  Return value:

    0 if successful, non-zero otherwise.

*/
CREATE PROCEDURE [$(SchemaName)].[AssignVariable] 
  @Job       NVARCHAR(64),
  @Variable  NVARCHAR(64),
  @Value     SQL_VARIANT
AS
BEGIN
  
  SET NOCOUNT ON;

  IF NOT EXISTS (SELECT 1 FROM [$(SchemaName)].Job WHERE Name = @Job)
  BEGIN
    RAISERROR('Job [%s] not found. INSERT table Job to create.',16,1,@job);
    RETURN 1;
  END;

  IF NOT EXISTS (SELECT 1 FROM [$(SchemaName)].Variable WHERE Name = @Variable)
  BEGIN
    RAISERROR('Variable [%s] not found. INSERT table Variable to create.',16,1,@variable);
    RETURN 1;
  END;  

  IF @Value IS NULL
  BEGIN
    RAISERROR('Value cannot be null.',16,1);
    RETURN 1;
  END; 

  IF NOT EXISTS (
    SELECT 1
    FROM
      [$(SchemaName)].JobVariable
    WHERE	
      Job = @Job
      AND Variable = @Variable
    ) INSERT [$(SchemaName)].JobVariable (Job, Variable, Value) 
      VALUES (@Job, @Variable, @Value)
  ELSE
    UPDATE [$(SchemaName)].JobVariable
      SET Value = @Value
    WHERE
      Job = @Job
      AND Variable = @Variable
      ; 

  RETURN 0;

END
GO
PRINT N'Creating [$(SchemaName)].[PrepareRoutine]...';


GO





/*

  PrepareRoutine

  Produces the command statement(s) to be executed by the system EXECUTE 
  function for each rule when a job is run. This may alternatively be used to
  debug a run-time condition.

  Rule must already be assigned to the job in table JobRule.

  Parameters:

    @Job - The unique name of the job to which to prepare the routine. The 
      variables already assigned to the job will be evaluated.

    @Rule - The unique name of the rule to which to prepare the routine.

    @Log - The name of the log which will be referenced in the routine.

    @Routine - The command statement(s) which comprise the routine. This is an
      "output parameter" that is set by the procedure to be read by the caller.

  Return value:

    0 if successful; non-zero, otherwise.

*/
CREATE PROCEDURE [$(SchemaName)].[PrepareRoutine] 
  @Job      NVARCHAR(64),
  @Rule     NVARCHAR(64),
  @Log      NVARCHAR(64),
  @Routine  NVARCHAR(MAX) OUTPUT
AS
BEGIN
  
  SET NOCOUNT ON;

  DECLARE @UserBlock NVARCHAR(MAX),
    @Severity NVARCHAR(64);

  SELECT 
    @UserBlock = [Rule].[Statement],
    @Severity = JobRule.Severity
  FROM 
    [$(SchemaName)].JobRule
    INNER JOIN 
    [$(SchemaName)].[Rule] ON JobRule.[Rule] = [Rule].Name 
  WHERE 
    JobRule.Job = @Job
    AND JobRule.[Rule] = @Rule
    AND JobRule.[Disabled] = 0;

  IF @UserBlock IS NULL
  BEGIN
    RAISERROR('Job rule [%s].[%s] not found.',16,1,@Job,@Rule);
    RETURN 1;
  END;

  IF @Log IS NULL
  BEGIN
    RAISERROR('Log is required.',16,1);
    RETURN 1;
  END;

  DECLARE @Indent NVARCHAR(8) = $(SchemaName).ConfigurePrepareIndent(),
    @Newline NVARCHAR(8) = $(SchemaName).ConfigurePrepareNewline(),
    @DurationUnit NVARCHAR(64) = $(SchemaName).ConfigurePrepareDurationUnit(),
    @DataRowFormat NVARCHAR(64) = $(SchemaName).ConfigurePrepareRowDataFormat();



  /* Assemble the variables in @VariableBlock */

  DECLARE
    @Variable VARCHAR(64),
    @Value SQL_VARIANT,
    @BaseType NVARCHAR(256),
    @MaxLength INT,
    @VariableBlock NVARCHAR(MAX)
    ;

  DECLARE VariableCursor CURSOR
  FOR
  SELECT
    JobVariable.Variable,
    JobVariable.[Value]
  FROM
    [$(SchemaName)].JobVariable
  WHERE
    JobVariable.Job = @Job;

  OPEN VariableCursor;

  WHILE 1=1
  BEGIN

    FETCH NEXT FROM VariableCursor
    INTO
      @Variable,
      @Value;

    IF @@FETCH_STATUS <> 0 
      BREAK;

    SET @BaseType = CAST(SQL_VARIANT_PROPERTY (@Value,'BaseType') AS NVARCHAR(256));
    SET @MaxLength = CAST(SQL_VARIANT_PROPERTY (@Value,'MaxLength') AS INT);

    SET @VariableBlock = (
      ISNULL(@VariableBlock,'')+
        'DECLARE @'+@Variable+' '+
        CASE
          WHEN @BaseType IN ('varchar','char') THEN
            @BaseType + '('+CAST(@MaxLength AS NVARCHAR) + ') = ''' + CAST(@Value AS NVARCHAR(4000)) + ''';'
          WHEN @BaseType IN ('nvarchar','nchar') THEN
            @BaseType + '('+CAST((@MaxLength/2) AS NVARCHAR) + ') = N''' + CAST(@Value AS NVARCHAR(4000)) + ''';'
          ELSE
            @BaseType + ' = ' + CAST(@Value AS NVARCHAR(64)) + ';'
        END
        +@Newline
      );
        
  END;

  CLOSE VariableCursor;
  DEALLOCATE VariableCursor;

  /* 
   *  Set @Routine with statement to execute/parse 
   */

  SET @Routine = (
    '/*<meta> '+@Newline+
    @Indent+'<job>'+@Job+'</job>'+@Newline+
    @Indent+'<rule>'+@Rule+'</rule>'+@Newline+
    @Indent+'<log>'+@Log+'</log>'+@Newline+
    @Indent+'</meta>*/'+@Newline+
    'DECLARE @RowDataRESERVED NVARCHAR(MAX) = NULL, '+@Newline+
    @Indent+'@TimeRESERVED DATETIME2 = GETUTCDATE(); '+@Newline+
    @VariableBlock+@Newline+
    'BEGIN TRY '+@Newline+
    'SET @RowDataRESERVED = CAST(( '+@Newline+
    '/*>>>User Block Starts Here<<<*/ '+@Newline+
    @UserBlock+@Newline+
    '/*>>>User Block Ends Here<<<*/ FOR '+@DataRowFormat+') AS NVARCHAR(MAX)); '+@Newline+
    'INSERT $(SchemaName).Log ( '+@Newline+
    @Indent+'[Time],[Status],Job,[Rule],Severity,RowData,Duration,[Exception],Log'+@Newline+
    @Indent+') VALUES ( '+@Newline+
    @Indent+'@TimeRESERVED, '+@Newline+
    @Indent+'IIF(@RowDataRESERVED IS NULL,''PASS'',''FAIL''), '+@Newline+
    @Indent+''''+@Job+''','+@Newline+
    @Indent+''''+@Rule+''','+@Newline+
    @Indent+''''+@Severity+''','+@Newline+
    @Indent+'LEFT(@RowDataRESERVED,4000),'+@Newline+
    @Indent+'DATEDIFF('+@DurationUnit+',@TimeRESERVED,GETUTCDATE()),'+@Newline+
    @Indent+'NULL,'+@Newline+
    @Indent+''''+@Log+''''+@Newline+
    @Indent+'); '+@Newline+
    'END TRY '+@Newline+
    'BEGIN CATCH '+@Newline+  
    'INSERT $(SchemaName).Log ( '+@Newline+
    @Indent+'[Time],[Status],Job,[Rule],Severity,RowData,Duration,[Exception],Log'+@Newline+
    @Indent+') VALUES ( '+@Newline+
    @Indent+'@TimeRESERVED,'+@Newline+
    @Indent+'''EXCEPTION'','+@Newline+
    @Indent+''''+@Job+''','+@Newline+
    @Indent+''''+@Rule+''','+@Newline+
    @Indent+''''+@Severity+''','+@Newline+
    @Indent+'NULL,'+@Newline+
    @Indent+'DATEDIFF('+@DurationUnit+',@TimeRESERVED,GETUTCDATE()),'+@Newline+
    @Indent+'''Msg ''+CAST(ERROR_NUMBER() AS VARCHAR) +'', Line ''+CAST(ERROR_LINE() AS VARCHAR)+'': ''+ERROR_MESSAGE(), '+@Newline+
    @Indent+''''+@Log+''''+@Newline+
    @Indent+'); '+@Newline+
    'END CATCH'
    );

    RETURN 0;
END
GO
PRINT N'Creating [$(SchemaName)].[RunJob]...';


GO



/*

  RunJob

  Runs a job and logs result to the named log.

  Job must already be defined in table Job.

  Parameters:

    @Job - The unique name of the job to run.

    @Log - The name of the log which to log to. If no log is specified a new 
      log name will be allocated and set by the procedure to be read by the 
      caller.

    @Verbose - If set to true (1), extra information will be will be output.
      Default is false (0).

  Return value:

    0 if successful, non-zero otherwise.

*/
CREATE PROCEDURE [$(SchemaName)].[RunJob] 
  @Job      NVARCHAR(64),
  @Log      VARCHAR(64) OUTPUT,
  @Verbose  BIT = 0
AS
BEGIN
  
  SET NOCOUNT ON;

  IF NOT EXISTS (SELECT 1 FROM [$(SchemaName)].Job WHERE Name = @Job)
  BEGIN
    RAISERROR('Job [%s] not found.',16,1,@Job);
    RETURN 1;
  END;

  IF @Log IS NULL
  BEGIN
    /*  Generate unqiue log name  */
    SET @Log = CAST(NEWID() AS NVARCHAR(36));
  END;

  RAISERROR(
    'Started job [%s]. See log [%s] for details.',0,0,
    @Job,
    @Log
    ) WITH NOWAIT;


  /* 
   * Run queries enabled for the job 
   */

  DECLARE
    @Rule VARCHAR(64),
    @Routine NVARCHAR(MAX),
    @CursorPosition INT = 1,
    @CursorRows INT
    ;

  DECLARE RuleCursor CURSOR
    FORWARD_ONLY STATIC READ_ONLY
    FOR
    SELECT [Rule]
    FROM [$(SchemaName)].JobRule
    WHERE Job = @job AND [Disabled] = 0
    ORDER BY [Rule] ASC;

  OPEN RuleCursor;

  SET @CursorRows = @@CURSOR_ROWS;

  WHILE 1=1
  BEGIN  

    FETCH NEXT 
    FROM RuleCursor
    INTO @Rule;

    IF @@FETCH_STATUS <> 0 
      BREAK;

    RAISERROR(
      'Running [%s] %d of %d',0,0,
        @Rule,
        @CursorPosition,
        @CursorRows
        ) WITH NOWAIT;

    EXECUTE [$(SchemaName)].PrepareRoutine 
      @Job=@Job, 
      @Rule=@Rule, 
      @Log=@Log,
      @Routine=@Routine OUTPUT;

    IF @Verbose = 1
      RAISERROR(
      '%s',0,0,
        @Routine
        ) WITH NOWAIT;

    EXECUTE (@Routine);

    SET @CursorPosition = @CursorPosition+1;

  END;

  CLOSE RuleCursor;
  DEALLOCATE RuleCursor;

  RETURN 0;

END
GO
PRINT N'Creating [$(SchemaName)].[AssignRule]...';


GO





/*

  AssignRule

  Assigns a rule to a job. If the rule is already assigned, updates the 
  severity and whether it is disabled.

  This procdure also verifies the rule DML statement with variables already 
  assigned to the job.

  Job, Severity, and Rule must already be defined in tables Job, Severity
  and Rule, respectively.

  Parameters:

    @Job - The unique name of the job to which to assign the rule.

    @Group - The unique name of the rule to assign.

    @Severity - What severity rule failures will be treated.

    @Disabled - Whether the rule will be disabled on assignment. 
      Default false (0).

  Return value:

    0 if successful, non-zero otherwise.

*/
CREATE PROCEDURE [$(SchemaName)].[AssignRule] 
  @Job       NVARCHAR(64),
  @Rule      NVARCHAR(64),
  @Severity  NVARCHAR(64),
  @Disabled  BIT = 0
AS
BEGIN
  
  SET NOCOUNT ON;

  IF NOT EXISTS (SELECT 1 FROM [$(SchemaName)].Job WHERE name = @Job)
  BEGIN
    RAISERROR('Job [%s] not found. INSERT table Job to create.',16,1,@Job);
    RETURN 1;
  END;

  IF NOT EXISTS (SELECT 1 FROM [$(SchemaName)].[Rule] WHERE name = @Rule)
  BEGIN
    RAISERROR('Rule [%s] not found. INSERT table Rule to create.',16,1,@Rule);
    RETURN 1;
  END;

  SET @Disabled = ISNULL(@Disabled,0);

BEGIN TRY

  BEGIN TRANSACTION;

  IF NOT EXISTS (
    SELECT
      1
    FROM
      [$(SchemaName)].JobRule
    WHERE	
      JobRule.Job = @Job
      AND JobRule.[Rule] = @Rule
    ) 
  BEGIN  

    IF NOT EXISTS (SELECT 1 FROM [$(SchemaName)].[Severity] WHERE Name = @Severity)
    BEGIN
      RAISERROR('Severity [%s] not found. INSERT table Severity to create.',16,1,@Severity);

    END;

    INSERT [$(SchemaName)].JobRule (Job, [Rule], Severity, [Disabled]) 
      VALUES (@Job, @Rule, @Severity, @Disabled);

  END
  ELSE
  BEGIN

    IF @Severity IS NOT NULL
      UPDATE [$(SchemaName)].JobRule
        SET Severity = @Severity,
          [Disabled] = @Disabled
      WHERE
        Job = @Job
        AND [Rule] = @Rule
    ELSE
      UPDATE [$(SchemaName)].JobRule
        SET [Disabled] = @Disabled
      WHERE
        Job = @Job
        AND [Rule] = @Rule
      ; 

  END;

  IF @Disabled = 0
  BEGIN

    DECLARE @Routine NVARCHAR(4000);

    EXEC [$(SchemaName)].PrepareRoutine 
      @Job=@Job, 
      @Rule=@Rule, 
      @Log='AssignRule',
      @Routine=@Routine OUTPUT;

    SET @Routine = ('SET NOEXEC ON; ' + @Routine);

    EXECUTE (@Routine);
    
  END;

  COMMIT TRANSACTION;

  RETURN 0;

END TRY
BEGIN CATCH

  ROLLBACK TRANSACTION;
  THROW;

  RETURN 1;

END CATCH

END
GO
PRINT N'Creating [$(SchemaName)].[Example]...';


GO







/*

  Example

  This procedure demonstrates suggested pattern and usage of all tables, veiws,
  and procedures.

*/
CREATE PROCEDURE [$(SchemaName)].[Example]
AS
BEGIN

SET NOCOUNT ON;

/*  Clean up anything  */
DELETE FROM $(SchemaName).Job WHERE Name LIKE 'Example%';
DELETE FROM $(SchemaName).Variable WHERE Name LIKE 'Example%';
DELETE FROM $(SchemaName).[Rule] WHERE Name LIKE 'Example%';



/*  Setting up test data to validate  */
  
IF OBJECT_ID('dbo.StudentExample','U') IS NOT NULL
  DROP TABLE dbo.StudentExample;

CREATE TABLE dbo.StudentExample (
  Id							INT IDENTITY(1,1) NOT NULL,
  Name						NVARCHAR(764) NULL,
  BirthDate				DATE NULL,
  StudentUniqueId NVARCHAR(32) NULL
  );

INSERT INTO dbo.StudentExample (Name,BirthDate,StudentUniqueId) 
  VALUES ('John Doe','1970-01-01','000001');
INSERT INTO dbo.StudentExample (Name,BirthDate,StudentUniqueId) 
  VALUES ('John Doe Jr','2000-01-01','000002');
INSERT INTO dbo.StudentExample (Name,BirthDate,StudentUniqueId) 
  VALUES ('John Doe 3rd','2020-01-01','000002');

SELECT * FROM dbo.StudentExample;



/*  Define variables to be referred to in validation rules */

INSERT $(SchemaName).Variable (Name, Description) VALUES (

  'ExampleBirthYearThreshold',
  'Example variable for birth year threshold'
  
  );

/*  Define variables to be referred to in validation rules */

INSERT $(SchemaName).Variable (Name, Description) VALUES (

  'ExampleNameMask',
  'Example Variable to mask out certain names'
  
  );



/*  Define rules  */

INSERT $(SchemaName).[Rule] (Name, Description, Statement) VALUES (
  
  'Example.1',
  'BirthDate Below Threshold',

  /* this rule references ExampleBirthYearThreshold variable */
 'SELECT id, BirthDate 
  FROM dbo.StudentExample 
  WHERE YEAR(BirthDate) < @ExampleBirthYearThreshold'
  
  );


INSERT $(SchemaName).[Rule] (Name, Description, Statement) VALUES (
  
  'Example.2', 
  'StudentUniqueID Not Unique',

 'SELECT StudentUniqueID 
  FROM dbo.StudentExample 
  GROUP BY StudentUniqueID HAVING COUNT(*) > 1'
  
  );

INSERT $(SchemaName).[Rule] (Name, Description, Statement) VALUES (
  
  'Example.3',
  'Name Contains Numbers',

 'SELECT id, Name 
  FROM dbo.StudentExample 
  WHERE Name LIKE ''%[0-9]%''' 
  
  );

INSERT $(SchemaName).[Rule] (Name, Description, Statement) VALUES (
  
  'Example.4', 	
  'Name Not Empty',

 'SELECT id, Name 
  FROM dbo.StudentExample 
  WHERE LEN(Name) = 0'
 
  ); 

INSERT $(SchemaName).[Rule] (Name, Description, Statement) VALUES (
  
  'Example.5', 	
  'Name is matches name mask',

  /* this rule references ExampleNameMask variable */
 'SELECT id, Name 
  FROM dbo.StudentExample 
  WHERE Name LIKE @ExampleNameMask'
 
  ); 
  


/*  Define job  */

INSERT $(SchemaName).Job (Name, Description) VALUES (
  'Example Job',
  'This is our example job'
  );


/*  Assign variables for job */
EXEC $(SchemaName).AssignVariable 
  @Job = 'Example Job',
  @Variable = 'ExampleBirthYearThreshold',
  @Value = 2000;

EXEC $(SchemaName).AssignVariable 
  @Job = 'Example Job',
  @Variable = 'ExampleNameMask',
  @Value = '%John Doe%';


/*  Assign rules to job  */
EXEC $(SchemaName).AssignRule 
  @Job = 'Example Job',
  @Rule = 'Example.1',
  @Severity = 'WARNING';

EXEC $(SchemaName).AssignRule
  @Job = 'Example Job',
  @Rule = 'Example.2',
  @Severity = 'ERROR';

EXEC $(SchemaName).AssignRule
  @Job = 'Example Job',
  @Rule = 'Example.3',
  @Severity = 'WARNING';

EXEC $(SchemaName).AssignRule
  @Job = 'Example Job',
  @Rule = 'Example.4',
  @Severity = 'WARNING';

EXEC $(SchemaName).AssignRule
  @Job = 'Example Job',
  @Rule = 'Example.5',
  @Severity = 'WARNING';


DECLARE @Log NVARCHAR(64);

/*  Run job  */
EXEC $(SchemaName).RunJob
  @Job = 'Example Job',
  @Log = @Log OUTPUT
  ,@Verbose = 1
  ;

/* Inspect job config */
SELECT * FROM $(SchemaName).[Job];
SELECT * FROM $(SchemaName).JobVariableHelp;
SELECT * FROM $(SchemaName).JobRuleHelp;

/*  Return rowset of the log  */
SELECT * FROM $(SchemaName).[Log] WHERE [Log] = @Log;

END;
GO
PRINT N'Checking existing data against newly created constraints';


GO
ALTER TABLE [$(SchemaName)].[JobRule] WITH CHECK CHECK CONSTRAINT [FK_$(SchemaName)_JobRule_Job];

ALTER TABLE [$(SchemaName)].[JobRule] WITH CHECK CHECK CONSTRAINT [FK_$(SchemaName)_JobRule_Rule];

ALTER TABLE [$(SchemaName)].[JobRule] WITH CHECK CHECK CONSTRAINT [FK_$(SchemaName)_JobRule_Severity];

ALTER TABLE [$(SchemaName)].[RuleGroup] WITH CHECK CHECK CONSTRAINT [FK_$(SchemaName)_RuleGroup_Group];

ALTER TABLE [$(SchemaName)].[RuleGroup] WITH CHECK CHECK CONSTRAINT [FK_$(SchemaName)_RuleGroup_Rule];

ALTER TABLE [$(SchemaName)].[JobVariable] WITH CHECK CHECK CONSTRAINT [FK_$(SchemaName)_JobVariable_Job];

ALTER TABLE [$(SchemaName)].[JobVariable] WITH CHECK CHECK CONSTRAINT [FK_$(SchemaName)_JobVariable_Variable];

ALTER TABLE [$(SchemaName)].[Variable] WITH CHECK CHECK CONSTRAINT [CK_$(SchemaName)_Variable_Name];

ALTER TABLE [$(SchemaName)].[Rule] WITH CHECK CHECK CONSTRAINT [CK_$(SchemaName)_Rule_Statement];


GO
PRINT N'Update complete.';


GO
